
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1 
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}

1.  К моменту выполнения данной строки JVM при помощи загрузчика
Classloader в область памяти Metaspace загрузила класс JvmComprehension, а также подготовила в Stack Memory специальную область памяти Frame метода main и поместила в этот Frame переменную значимого типа int i = 1;

2. Данная строка включает в себя 3 подэтапа: объявление переменной o типа Object, выделение памяти в хипе (т.е. создание экземпляра класса) и присвоение (знак "равно"). Сам объект Object создается в хипе, а во Frame (которая в свою очередь находится в Stack Memory) помещается ссылка на данную переменную.

3. По аналогии со 2 строкой, в куче будет создан экземпляр ii типа Integer, ссылка на него будет передана во Frame метода main, переменная ii будет проинициализирована значением 2.

4. На строке 4 будет создан новый Frame метода printAll. В этот Frame будут помещены ссылки o и ii на объекты в хипе и создана копия переменной значимого типа i.

5. Аналогия с шагом 2: в куче будет создан экземпляр uselessVar типа Integer, ссылка на него будет передана в раннее созданный Frame метода printAll, будет присвоено интовое значение 700.

6. Создание в стеке нового Frame для метода println. Поскольку в параметрах метода println заявлено сложение, то во Frame помещается ссылка на переменную объекта в куче типа StringBuilder или StringBuffer (в зависимости от поточности, поскольку сам тип String иммьютебл, измениню не подлежит, а значит сам он сложить ничего не может). И, поскольку конкатенация строк через StringBuffer в Java выполняется с помощью метода append, то для метода append создаётся свой Frame. Также Frame создаётся для метода toString, куда помещается объект o. Во Frame метода append помещается результат работы o.toString, а также ii и копия i. После отработки Frame уничтожаются. Данные выводятся на консоль и Frame метода println уничтожается. Далее, в связи с отработкой метода printAll, - уничтожается его Frame.

7. Создание Frame для метода println со строкой "finished". Создание в куче объекта String со ссылкой в Stack Memory. Вывод на экран строки "finished".

    7.1 Уничтожение Frame метода println.  
    7.2 Уничтожение Frame метода main.